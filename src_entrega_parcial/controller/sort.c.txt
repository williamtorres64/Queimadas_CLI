#include "server.h"

void swap_queimadas(Queimada *a, Queimada *b)
{
    Queimada temp = *b;
    b->id = a->id;
    b->lat = a->lat;
    b->lon = a->lon;
    b->data = a->data;
    b->hora = a->hora;
    b->timestamp = a->timestamp;
    b->estadoId = a->estadoId;
    b->municipioId = a->municipioId;
    b->biomaId = a->biomaId;

    a->id = temp.id;
    a->lat = temp.lat;
    a->lon = temp.lon;
    a->data = temp.data;
    a->hora = temp.hora;
    a->timestamp = temp.timestamp;
    a->estadoId = temp.estadoId;
    a->municipioId = temp.municipioId;
    a->biomaId = temp.biomaId;
}

void bubble_sort(Server *server, char ordenar_por)
{
    if (!server || !server->queimadas)
        return;

    if (!server->queimadas->next)
        return;

    bool swapped;
    do
    {
        swapped = false;
        Queimada *qi = server->queimadas;

        while (qi != NULL && qi->next != NULL)
        {
            bool do_swap = false;
            switch (ordenar_por)
            {
            case 'd':
                if (qi->timestamp > qi->next->timestamp)
                    do_swap = true;
                break;
            case 'a':
                if (qi->lat > qi->next->lat)
                    do_swap = true;
                break;
            case 'o':
                if (qi->lon > qi->next->lon)
                    do_swap = true;
                break;
            case 'm':
                if (qi->municipioId > qi->next->municipioId)
                    do_swap = true;
                break;
            default:
                break;
            }

            if (do_swap)
            {
                swap_queimadas(qi, qi->next);
                swapped = true;
            }

            qi = qi->next;
        }
    } while (swapped);
}

static bool should_a_come_first(Queimada *a, Queimada *b, char ordenar_por)
{
    switch (ordenar_por)
    {
    case 'd':
        return a->timestamp <= b->timestamp;
    case 'a':
        return a->lat <= b->lat;
    case 'o':
        return a->lon <= b->lon;
    case 'm':
        return a->municipioId <= b->municipioId;
    default:
        return a->timestamp <= b->timestamp;
    }
}

static Queimada *sortedMerge(Queimada *a, Queimada *b, char ordenar_por)
{
    if (a == NULL)
    {
        return b;
    }
    if (b == NULL)
    {
        return a;
    }

    Queimada *result = NULL;

    if (should_a_come_first(a, b, ordenar_por))
    {
        result = a;
        result->next = sortedMerge(a->next, b, ordenar_por);
    }
    else
    {
        result = b;
        result->next = sortedMerge(a, b->next, ordenar_por);
    }

    return result;
}

static Queimada *getMiddle(Queimada *head)
{
    if (head == NULL)
    {
        return head;
    }

    Queimada *slow = head;
    Queimada *fast = head->next;

    while (fast != NULL)
    {
        fast = fast->next;
        if (fast != NULL)
        {
            slow = slow->next;
            fast = fast->next;
        }
    }
    return slow;
}

static Queimada *mergeSortRecursive(Queimada *head, char ordenar_por)
{
    if (head == NULL || head->next == NULL)
    {
        return head;
    }

    Queimada *middle = getMiddle(head);

    Queimada *right_half = middle->next;
    middle->next = NULL;
    Queimada *left_half = head;

    Queimada *sorted_left = mergeSortRecursive(left_half, ordenar_por);
    Queimada *sorted_right = mergeSortRecursive(right_half, ordenar_por);

    return sortedMerge(sorted_left, sorted_right, ordenar_por);
}

void merge_sort(Server *server, char ordenar_por)
{
    if (!server || !server->queimadas || !server->queimadas->next)
    {
        return;
    }

    Queimada *new_head = mergeSortRecursive(server->queimadas, ordenar_por);

    server->queimadas = new_head;
}